// Types for accommodations - UNIFIED MODEL
// Combines AI suggestions and user reservations into a single system

// ============================================================
// UNIFIED ACCOMMODATION MODEL (NEW)
// ============================================================

/**
 * Unified type of accommodation
 */
export type AccommodationType =
  | 'hotel'
  | 'airbnb'
  | 'hostel'
  | 'resort'
  | 'vacation_rental'
  | 'apartment'
  | 'other'

/**
 * Origin of the accommodation - how it was created
 */
type AccommodationOrigin = 'ai_suggestion' | 'user_added'

/**
 * Status in the accommodation lifecycle
 */
export type AccommodationStatus = 'suggested' | 'pending' | 'confirmed' | 'cancelled'

/**
 * Confidence of the Google Places matching
 */
export type AccommodationMatchConfidence = 'exact' | 'high' | 'low' | 'none'

/**
 * Source of the accommodation - how it was added to the system
 */
type AccommodationSource =
  | 'email_forward'    // User forwarded confirmation email
  | 'receipt_upload'   // User uploaded PDF/image
  | 'gmail_sync'       // Auto-synced from Gmail (future)
  | 'manual_entry'     // User entered manually
  | 'hotel_search'     // Selected from hotel search
  | 'ai_generated'     // Generated by AI

/**
 * Place data from Google Places for accommodations
 */
export interface AccommodationPlaceData {
  name: string
  rating?: number
  reviewCount?: number
  coordinates: { lat: number; lng: number }
  address?: string
  city?: string         // Ciudad extraída de Google Places addressComponents
  country?: string      // País extraído de Google Places addressComponents
  images?: string[]
  googleMapsUrl?: string
  website?: string
  phone?: string
  amenities?: string[]
  openingHours?: string[]
}

/**
 * Booking link from OTA providers (via SerpAPI or direct)
 */
export interface BookingLink {
  provider: string           // "Booking.com", "Expedia", "Hotels.com", etc.
  price: number
  currency: string
  originalUrl: string        // URL from SerpAPI
  affiliateUrl?: string      // URL with affiliate tracking
  deal?: string              // "20% off", "Free breakfast"
  logo?: string              // Provider logo URL
}

/**
 * UNIFIED Accommodation Model
 *
 * Combines AI suggestions and user reservations into a single type.
 * Lifecycle: suggested → pending → confirmed
 *
 * AI generates with origin='ai_suggestion', status='suggested'
 * User accepts → status='pending'
 * User confirms booking → status='confirmed'
 * User adds their own → origin='user_added', status='pending' or 'confirmed'
 */
export interface Accommodation {
  id: string

  // Basic info
  name: string
  type: AccommodationType
  area: string               // "La Fortuna", "Manuel Antonio"

  // Dates
  checkIn: string            // ISO date
  checkOut: string           // ISO date
  checkInTime?: string       // "3:00 PM"
  checkOutTime?: string      // "11:00 AM"
  nights: number

  // Pricing
  pricePerNight?: number
  totalPrice?: number
  currency: string

  // Google Places linking (same pattern as Activity)
  googlePlaceId?: string
  placeData?: AccommodationPlaceData
  matchConfidence?: AccommodationMatchConfidence

  // Booking links from OTAs (via SerpAPI)
  bookingLinks?: BookingLink[]

  // Origin and status (lifecycle)
  origin: AccommodationOrigin
  status: AccommodationStatus

  // Booking details (for confirmed or user_added)
  confirmationNumber?: string
  bookingPlatform?: string   // "Booking.com", "Airbnb", "Expedia"
  bookingUrl?: string

  // AI info (for ai_suggestion)
  whyThisPlace?: string      // "Ubicación perfecta para visitar el volcán"
  amenities?: string[]       // ["WiFi", "Pool", "Parking"]

  // Source metadata (how user added it)
  source?: AccommodationSource

  // User notes
  notes?: string

  // Timestamps
  createdAt: string
  updatedAt: string
}

// ============================================================
// EXTRACTION HELPERS (for email/receipt parsing)
// ============================================================

/**
 * Data extracted by AI from email/receipt
 */
export interface ExtractedAccommodationData {
  name?: string
  type?: AccommodationType
  address?: string
  city?: string
  country?: string
  checkIn?: string
  checkOut?: string
  checkInTime?: string
  checkOutTime?: string
  pricePerNight?: number
  totalPrice?: number
  currency?: string
  confirmationNumber?: string
  bookingPlatform?: string
  phone?: string
  email?: string
  guestNames?: string[]
  amenities?: string[]
  confidence: number  // 0-1, how confident AI is in the extraction
  error?: string      // If extraction failed
}

/**
 * Helper: Calculate nights between two dates
 */
export function calculateNights(checkIn: string, checkOut: string): number {
  const start = new Date(checkIn)
  const end = new Date(checkOut)
  const diffTime = Math.abs(end.getTime() - start.getTime())
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  return diffDays
}

/**
 * Helper: Create accommodation from extracted data
 */
export function createAccommodationFromExtracted(
  extracted: ExtractedAccommodationData,
  source: 'email_forward' | 'receipt_upload'
): Accommodation {
  const now = new Date().toISOString()
  const nights = extracted.checkIn && extracted.checkOut
    ? calculateNights(extracted.checkIn, extracted.checkOut)
    : 0

  return {
    id: crypto.randomUUID(),
    name: extracted.name || 'Unknown Hotel',
    type: extracted.type || 'hotel',
    area: extracted.city || '',
    checkIn: extracted.checkIn || '',
    checkOut: extracted.checkOut || '',
    checkInTime: extracted.checkInTime,
    checkOutTime: extracted.checkOutTime,
    nights,
    pricePerNight: extracted.pricePerNight,
    totalPrice: extracted.totalPrice,
    currency: extracted.currency || 'USD',
    origin: 'user_added',
    status: 'pending',
    confirmationNumber: extracted.confirmationNumber,
    bookingPlatform: extracted.bookingPlatform,
    amenities: extracted.amenities,
    source,
    createdAt: now,
    updatedAt: now,
  }
}

// ============================================================
// UNIFIED MODEL HELPERS
// ============================================================

/**
 * Create a new AI-generated accommodation suggestion
 */
function createAISuggestion(data: {
  name: string
  type: AccommodationType
  area: string
  checkIn: string
  checkOut: string
  pricePerNight?: number
  whyThisPlace?: string
  amenities?: string[]
  googlePlaceId?: string
}): Accommodation {
  const now = new Date().toISOString()
  const nights = calculateNights(data.checkIn, data.checkOut)

  return {
    id: crypto.randomUUID(),
    name: data.name,
    type: data.type,
    area: data.area,
    checkIn: data.checkIn,
    checkOut: data.checkOut,
    nights,
    pricePerNight: data.pricePerNight,
    totalPrice: data.pricePerNight ? data.pricePerNight * nights : undefined,
    currency: 'USD',
    googlePlaceId: data.googlePlaceId,
    origin: 'ai_suggestion',
    status: 'suggested',
    whyThisPlace: data.whyThisPlace,
    amenities: data.amenities,
    source: 'ai_generated',
    createdAt: now,
    updatedAt: now,
  }
}

/**
 * Create a new user-added accommodation
 */
export function createUserAccommodation(data: {
  name: string
  type: AccommodationType
  area: string
  checkIn: string
  checkOut: string
  pricePerNight?: number
  totalPrice?: number
  currency?: string
  confirmationNumber?: string
  bookingPlatform?: string
  bookingUrl?: string
  notes?: string
  source: AccommodationSource
  status?: AccommodationStatus
}): Accommodation {
  const now = new Date().toISOString()
  const nights = calculateNights(data.checkIn, data.checkOut)

  return {
    id: crypto.randomUUID(),
    name: data.name,
    type: data.type,
    area: data.area,
    checkIn: data.checkIn,
    checkOut: data.checkOut,
    nights,
    pricePerNight: data.pricePerNight,
    totalPrice: data.totalPrice,
    currency: data.currency || 'USD',
    origin: 'user_added',
    status: data.status || 'pending',
    confirmationNumber: data.confirmationNumber,
    bookingPlatform: data.bookingPlatform,
    bookingUrl: data.bookingUrl,
    notes: data.notes,
    source: data.source,
    createdAt: now,
    updatedAt: now,
  }
}

/**
 * Get display name for accommodation status
 */
function getStatusDisplayName(status: AccommodationStatus): string {
  const names: Record<AccommodationStatus, string> = {
    suggested: 'Sugerencia AI',
    pending: 'Pendiente',
    confirmed: 'Confirmado',
    cancelled: 'Cancelado',
  }
  return names[status]
}

/**
 * Get status color class (for badges)
 */
function getStatusColorClass(status: AccommodationStatus): string {
  const colors: Record<AccommodationStatus, string> = {
    suggested: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300',
    pending: 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-300',
    confirmed: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300',
    cancelled: 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300',
  }
  return colors[status]
}

/**
 * Get display name for accommodation source
 */
export function getAccommodationSourceDisplayName(source: AccommodationSource): string {
  const names: Record<AccommodationSource, string> = {
    email_forward: 'Email',
    receipt_upload: 'Recibo',
    gmail_sync: 'Gmail',
    manual_entry: 'Manual',
    hotel_search: 'Búsqueda',
    ai_generated: 'AI',
  }
  return names[source]
}

/**
 * Get icon name for accommodation source
 */
function getAccommodationSourceIcon(source: AccommodationSource): string {
  const icons: Record<AccommodationSource, string> = {
    email_forward: 'mail-forward',
    receipt_upload: 'upload',
    gmail_sync: 'refresh-cw',
    manual_entry: 'edit',
    hotel_search: 'search',
    ai_generated: 'sparkles',
  }
  return icons[source]
}

/**
 * Check if an accommodation covers a specific date
 * Returns true if the date is within the stay (after checkIn, before or equal to checkOut)
 */
function accommodationCoversDate(accommodation: Accommodation, date: string): boolean {
  return date > accommodation.checkIn && date <= accommodation.checkOut
}

/**
 * Get the accommodation for a specific day with priority logic
 * Priority: confirmed > pending > suggested
 */
function getAccommodationForDate(
  date: string,
  accommodations: Accommodation[]
): Accommodation | null {
  const applicable = accommodations
    .filter(a => a.status !== 'cancelled')
    .filter(a => accommodationCoversDate(a, date))
    .sort((a, b) => {
      const priority: Record<AccommodationStatus, number> = {
        confirmed: 0,
        pending: 1,
        suggested: 2,
        cancelled: 3,
      }
      return priority[a.status] - priority[b.status]
    })

  return applicable[0] || null
}

/**
 * Find gaps in accommodation coverage between dates
 * Returns array of { startDate, endDate } for uncovered nights
 */
export function findAccommodationGaps(
  startDate: string,
  endDate: string,
  accommodations: Accommodation[]
): Array<{ startDate: string; endDate: string }> {
  const gaps: Array<{ startDate: string; endDate: string }> = []
  const activeAccommodations = accommodations.filter(a => a.status !== 'cancelled')

  // Generate all dates in the range
  const start = new Date(startDate)
  const end = new Date(endDate)
  const current = new Date(start)

  let gapStart: string | null = null

  while (current < end) {
    const dateStr = current.toISOString().split('T')[0]
    const nextDate = new Date(current)
    nextDate.setDate(nextDate.getDate() + 1)
    const nextDateStr = nextDate.toISOString().split('T')[0]

    // Check if this night is covered (we need accommodation for the night of dateStr)
    const isCovered = activeAccommodations.some(a =>
      dateStr >= a.checkIn && dateStr < a.checkOut
    )

    if (!isCovered) {
      if (!gapStart) {
        gapStart = dateStr
      }
    } else {
      if (gapStart) {
        gaps.push({ startDate: gapStart, endDate: dateStr })
        gapStart = null
      }
    }

    current.setDate(current.getDate() + 1)
  }

  // Close any remaining gap
  if (gapStart) {
    gaps.push({ startDate: gapStart, endDate: end.toISOString().split('T')[0] })
  }

  return gaps
}
